<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wordly</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;500;700&family=Outfit:wght@400;500;700&family=Pacifico&display=swap"
        rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        @font-face {
            font-family: 'GameFont';
            src: url('Recursos/GameFont.ttf') format('truetype');
            font-weight: 100 900;
            /* Soporta todos los pesos (Variable Font) */
            font-style: normal;
        }

        :root {
            /* Colores */
            --bg-body: #101012;
            --primary: #00C7FC;
            --primary-dark: #009ec9;
            --primary-20: rgba(0, 199, 252, 0.2);
            --primary-10: rgba(0, 199, 252, 0.1);
            --primary-05: rgba(0, 199, 252, 0.05);
            --success: #00EA71;
            --success-dark: #00b558;
            --warning: #FFB900;
            --warning-dark: #cc9400;
            --danger: #FF5F22;
            --danger-dark: #cc4c1b;
            --white: #FFFFFF;
            --input-bg: #1C1C1E;

            /* UI */
            --font: 'GameFont', 'DM Sans', sans-serif;
            --radius-btn: 16px;
            --radius-card: 20px;
            --radius-tile: 16px;
            --radius-tile-sm: 8px;
        }

        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font);
            font-variation-settings: 'ROND' 100;
            background-color: var(--bg-body);

            /* --- IMAGEN DE FONDO RECUPERADA --- */
            background-image: url('Recursos/Background.jpg');
            background-size: min(100%, 600px) auto;
            /* Ancho completo, mantiene proporci贸n */
            background-repeat: no-repeat;
            background-position: top center;
            background-attachment: fixed;
            /* Fijo para que no se mueva */

            color: var(--white);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            transition: background 0.3s ease;
        }

        /* Clase para quitar fondo SOLO al jugar */
        body.no-bg {
            background-image: none;
            background-color: #101012;
        }

        .hidden {
            display: none !important;
        }

        /* Pantallas */
        .screen {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 600px;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            padding: 24px 24px 32px 24px;
            transition: opacity 0.3s ease;
        }

        /* Intro & Connect: Alineados abajo con degradado */
        #screen-intro {
            justify-content: flex-end;
            background: transparent;
        }

        #screen-connect {
            justify-content: flex-end;
            /* Degradado para que el texto se lea sobre la imagen */
            background: linear-gradient(to bottom,
                    rgba(16, 16, 18, 0) 0%,
                    rgba(16, 16, 18, 0.4) 40%,
                    rgba(16, 16, 18, 0.98) 75%,
                    rgba(16, 16, 18, 1) 100%);
        }

        #screen-connect {
            justify-content: flex-end;
        }

        #screen-game {
            justify-content: flex-start;
            background: #101012;
            overflow-y: auto;
        }

        /* Logo */
        .logo-svg {
            width: 100%;
            padding: 0 32px;
            height: auto;
            margin-bottom: 32px;
            align-self: center;
            box-sizing: border-box;
        }

        .logo-game-svg {
            width: auto;
            height: 24px;
            margin-top: 8px;
            /* 24px padding + 8px = 32px visual top margin */
            margin-bottom: 32px;
            align-self: center;
            display: flex;
            /* Ensure it behaves as a container */
            justify-content: center;
        }

        /* Tipograf铆a */
        h2 {
            font-size: 2rem;
            margin: 0 0 8px 0;
            font-weight: 700;
            text-align: center;
            color: white;
        }

        .text-white {
            color: #FFFFFF !important;
            opacity: 1 !important;
            text-align: center;
        }

        .text-small {
            font-size: 0.9rem;
            color: #888;
            text-align: center;
        }

        .intro-text {
            margin-bottom: 16px;
            text-align: center;
            font-size: 16px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Inputs */
        input[type="text"] {
            background: transparent;
            box-shadow: none;
            border: 2px solid rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
            height: 56px;
            border-radius: var(--radius-btn);
            font-family: var(--font);
            font-variation-settings: 'ROND' 100;
            font-size: 16px;
            text-align: center;
            width: 100%;
            margin-bottom: 32px;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
            opacity: 1;
        }

        input[type="text"]:hover,
        input[type="text"]:focus {
            border-color: var(--primary) !important;
        }

        /* Botones */
        .btn-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .btn {
            height: 56px;
            border-radius: var(--radius-btn);
            border: none;
            font-family: var(--font);
            font-variation-settings: 'ROND' 100;
            font-weight: 600;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
            padding: 0 32px;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-full {
            width: 100%;
        }

        .btn-auto {
            width: auto;
            min-width: 140px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: #101012;
            box-shadow: inset 0 -6px 0 rgba(16, 16, 18, 0.2);
        }

        .btn-secondary,
        .btn-soft-blue {
            background-color: var(--primary-20);
            color: var(--white);
            box-shadow: inset 0 -6px 0 rgba(16, 16, 18, 0.2);
        }

        .btn-white {
            background-color: var(--white);
            color: #101012;
            box-shadow: inset 0 -6px 0 rgba(16, 16, 18, 0.2);
        }

        .btn-ghost {
            background-color: transparent;
            color: rgba(255, 255, 255, 0.6);
            box-shadow: none;
            font-size: 16px;
        }

        /* Estilo Deshabilitado (Esperando...) */
        .btn:disabled {
            background-color: #2C2C2E !important;
            color: rgba(255, 255, 255, 0.5) !important;
            border: 1px solid #444 !important;
            box-shadow: none !important;
            cursor: not-allowed;
            transform: none;
            margin-bottom: 0;
        }

        /* C贸digo ID - Legacy/Updated */
        .code-wrapper {
            background: rgba(0, 199, 252, 0.05);
            border-radius: 24px;
            padding: 8px;
            margin-top: 16px;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .code-display {
            font-family: monospace;
            color: var(--primary);
            font-size: 14px;
            text-align: center;
            margin-top: 16px;
            margin-bottom: 16px;
            word-break: break-all;
            padding: 0 10px;
        }

        .btn-copy {
            background-color: var(--primary-20);
            color: var(--white);
            box-shadow: inset 0 -6px 0 rgba(16, 16, 18, 0.2);
            border: none;
            border-radius: 16px;
            height: 56px;
            font-family: var(--font);
            font-variation-settings: 'ROND' 100;
            font-weight: 500;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s;
        }

        .btn-copy:active {
            transform: scale(0.98);
        }

        /* Connect Screen Specifics */
        #screen-connect h2 {
            font-size: 40px;
            font-weight: 500;
            margin-bottom: 32px;
        }

        .connect-instruction {
            font-size: 16px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
        }

        #friend-code {
            margin-bottom: 8px;
        }

        .divider {
            display: flex;
            align-items: center;
            width: 100%;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            font-weight: 400;
            margin: 20px 0;
        }

        .divider::before,
        .divider::after {
            content: "";
            flex: 1;
            height: 1px;
            background: #333;
            margin: 0 10px;
        }

        /* Game Board */
        .scoreboard-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 32px;
            transition: gap 0.5s;
        }

        /* Remove gap when timer is collapsed to rely on margin or just 0 gap if margin is used */
        .scoreboard-container:has(.timer-card.collapsed) {
            gap: 0;
        }

        .score-card {
            background: rgba(0, 199, 252, 0.1);
            border-radius: 32px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            height: 120px;
            position: relative;
        }

        /* Force gap when timer is collapsed */
        .scoreboard-container:has(.timer-card.collapsed) .score-card:first-child {
            margin-right: 8px;
        }

        .score-card span {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 500;
        }

        .avatar-icon {
            width: 32px;
            height: 32px;
            margin-bottom: 8px;
            display: block;
        }

        .score-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            width: 100%;
        }

        .score-card .val {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            transition: transform 0.2s;
        }

        /* Animaci贸n POP marcador */
        .score-card .val.pop {
            animation: scorePop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: var(--success);
        }

        @keyframes scorePop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.4);
            }

            100% {
                transform: scale(1);
            }
        }

        .score-card .added {
            font-size: 1rem;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.5s;
            position: absolute;
            left: 50%;
            transform: translateX(20px);
            /* Offset from center */
            white-space: nowrap;
        }

        .score-card .added.visible {
            opacity: 1;
        }

        .added.win {
            color: var(--success);
        }

        .added.draw {
            color: var(--warning);
        }

        .timer-card {
            background: rgba(0, 199, 252, 0.1);
            border-radius: 32px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 110px;
            height: 120px;
            transition: width 0.5s, opacity 0.5s, padding 0.5s;
        }

        .timer-card span {
            font-size: 12px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 4px;
        }

        .timer-card.collapsed {
            width: 0;
            padding: 0;
            opacity: 0;
            overflow: hidden;
            margin: 0;
            /* The gap is handled by the container, but we might need to trick it if flex gap persists */
        }

        /* Removed scoreFly animation */

        .timer-big {
            font-size: 48px !important;
            font-weight: 700;
            color: #FFFFFF;
            line-height: 1;
            margin-bottom: 4px;
        }

        .timer-label {
            font-size: 12px !important;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.6);
        }

        .word-zone-container {
            display: flex;
            justify-content: center;
            width: 100%;
            transition: width 0.2s ease-out;
            margin-bottom: 32px;
            height: 56px;

            /* Restored visual styles */
            background: rgba(0, 199, 252, 0.1);
            border: 2px solid rgba(0, 199, 252, 0.05);
            border-radius: 20px;
            padding: 8px;
            box-sizing: border-box;
            align-items: center;
            margin-left: auto;
            /* Fix centering */
            margin-right: auto;
            /* Fix centering */
        }

        .container-win {
            background: rgba(0, 234, 113, 0.1) !important;
            border-color: rgba(0, 234, 113, 0.05) !important;
        }

        .container-lose {
            background: rgba(255, 95, 34, 0.1) !important;
            border-color: rgba(255, 95, 34, 0.05) !important;
        }

        .container-error {
            background: rgba(255, 95, 34, 0.1) !important;
            border: 2px solid rgba(255, 95, 34, 0.05);
            /* Explicit border to override default if needed */
            border-radius: 20px;
            /* Ensure radius is kept */
        }

        .container-draw {
            background: rgba(255, 185, 0, 0.1) !important;
            border-color: rgba(255, 185, 0, 0.05) !important;
        }

        .word-zone {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: nowrap;
            width: 100%;
        }

        .word-zone .tile {
            width: 32px;
            height: 40px;
            font-size: 24px;
            border-radius: 12px;
            /* Inherit main tile styles */
            color: #000;
        }

        @media (hover: hover) {
            .word-zone .tile:hover {
                background-color: rgba(0, 199, 252, 0.6);
            }
        }

        .word-zone .tile:active {
            transform: translateY(3px);
            /* box-shadow handled by ::after */
        }

        .word-result-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 0;

            /* Container styles applied here too */
            background: rgba(0, 199, 252, 0.1);
            border: 2px solid rgba(0, 199, 252, 0.05);
            border-radius: 20px;
            padding: 8px;
            width: auto;
            display: inline-flex;
            min-height: 56px;
            align-items: center;
        }

        .word-result-row .tile {
            width: 32px;
            height: 40px;
            font-size: 24px;
            border-radius: 12px;
            /* Inherit main tile styles */
            color: #000;
        }

        .pool-zone {
            display: grid;
            grid-template-columns: repeat(5, min(64px, 17vw));
            gap: 8px;
            justify-content: center;
            /* margin-bottom: auto; Removed to fix centering */
            transition: opacity 0.3s;
        }

        .slot {
            width: min(64px, 17vw);
            height: min(80px, 21.25vw);
            background: rgba(0, 199, 252, 0.05);
            border-radius: var(--radius-tile);
            box-shadow: none;
        }

        .tile {
            width: min(64px, 17vw);
            height: min(80px, 21.25vw);
            background-color: var(--tile-color);
            /* Solid color */
            color: #000;
            font-size: min(48px, 12vw);
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
            position: relative;
            z-index: 5;
            background-color: transparent;
            /* Container is transparent */

            /* Default Colors */
            --tile-color: var(--primary);
            --shadow-color: var(--primary-dark);

            /* Box Shadow for 3D effect */
            /* box-shadow: 0 4px 0 var(--shadow-color); */

            /* Mobile Optimization - Force GPU acceleration */
            will-change: transform;
            transform: translate3d(0, 0, 0);
            -webkit-font-smoothing: antialiased;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            /* -webkit-transform: translate3d(0, 0, 0); */
            /* iOS specific */
        }

        /* Tile Face */
        .tile::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--tile-color);
            border-radius: 16px;
            z-index: 1;
            transition: background-color 0.2s;
        }

        /* 3D Depth using gradient */
        .tile::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 4px;
            background: linear-gradient(to bottom, var(--shadow-color), transparent);
            border-radius: 0 0 16px 16px;
            transform-origin: bottom center;
            z-index: 0;
            will-change: transform;
            transform: translate3d(0, 0, 0) scaleY(1);
        }

        @media (hover: hover) {
            .tile:hover {
                --tile-color: #00B3E3;
                animation: squash 0.5s ease-in-out;
            }
        }

        .tile:active {
            transform: translate3d(0, 4px, 0);
        }

        .tile:active::after {
            transform: translate3d(0, 0, 0) scaleY(0.1);
        }

        /* Animaciones */
        @keyframes squash {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02, 0.98);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-4px) rotate(-2deg);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(4px) rotate(2deg);
            }
        }

        .tile.shake {
            animation: shake 0.4s ease-in-out;
            --tile-color: var(--danger) !important;
            color: #101012 !important;
            --shadow-color: var(--danger-dark) !important;
        }

        @keyframes waveJump {
            0% {
                transform: translate3d(0, 0, 0);
            }

            40% {
                transform: translate3d(0, -14px, 0);
            }

            70% {
                transform: translate3d(0, 4px, 0);
            }

            85% {
                transform: translate3d(0, -4px, 0);
            }

            100% {
                transform: translate3d(0, 0, 0);
            }
        }

        @keyframes waveShadow {
            0% {
                transform: translate3d(0, 0, 0) scaleY(1);
            }

            40% {
                transform: translate3d(0, 14px, 0) scaleY(4.5);
            }

            70% {
                transform: translate3d(0, -4px, 0) scaleY(0);
            }

            85% {
                transform: translate3d(0, 4px, 0) scaleY(2);
            }

            100% {
                transform: translate3d(0, 0, 0) scaleY(1);
            }
        }

        .tile.validating {
            animation: waveJump 0.3s ease-in-out;
        }

        .tile.validating::after {
            animation: waveShadow 0.3s ease-in-out;
        }

        @keyframes waveJumpLoop {
            0% {
                transform: translate3d(0, 0, 0);
            }

            8% {
                transform: translate3d(0, -14px, 0);
            }

            14% {
                transform: translate3d(0, 4px, 0);
            }

            17% {
                transform: translate3d(0, -4px, 0);
            }

            20% {
                transform: translate3d(0, 0, 0);
            }

            100% {
                transform: translate3d(0, 0, 0);
            }
        }

        @keyframes waveShadowLoop {
            0% {
                transform: translate3d(0, 0, 0) scaleY(1);
            }

            8% {
                transform: translate3d(0, 14px, 0) scaleY(4.5);
            }

            14% {
                transform: translate3d(0, -4px, 0) scaleY(0);
            }

            17% {
                transform: translate3d(0, 4px, 0) scaleY(2);
            }

            20% {
                transform: translate3d(0, 0, 0) scaleY(1);
            }

            100% {
                transform: translate3d(0, 0, 0) scaleY(1);
            }
        }

        @keyframes winElevation {

            /* Exact copy of waveJump */
            0% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-14px);
            }

            70% {
                transform: translateY(4px);
            }

            85% {
                transform: translateY(-4px);
            }

            100% {
                transform: translateY(0);
            }
        }

        /* drawShadow uses winShadow keyframes */

        /* drawShadow uses same keyframes as winShadow, just different color handled by var */

        @keyframes winExplosion {
            0% {
                transform: scale(1) rotate(0deg);
            }

            30% {
                transform: scale(1.4) rotate(-15deg);
            }

            60% {
                transform: scale(1.1) rotate(10deg);
                background-color: var(--success);
                color: black;
            }

            100% {
                transform: scale(1) rotate(0deg);
                background-color: var(--success);
                color: black;
            }
        }

        @keyframes drawHighlight {
            0% {
                transform: scale(1);
                background-color: var(--warning);
            }

            50% {
                transform: scale(1.1);
                background-color: var(--warning);
            }

            100% {
                transform: scale(1);
                background-color: var(--warning);
            }
        }

        @keyframes scoreSlideLeft {
            0% {
                transform: translateX(0);
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                transform: translateX(-20px);
                opacity: 0;
            }
        }

        .score-fly {
            animation: scoreSlideLeft 0.8s ease-out forwards;
        }

        .tile.success {
            animation: waveJumpLoop 2s ease-in-out infinite;
            --tile-color: var(--success) !important;
            color: #101012 !important;
            --shadow-color: var(--success-dark) !important;
        }

        .tile.success::after {
            animation: waveShadowLoop 2s ease-in-out infinite;
        }

        .tile.fail {
            animation: shake 0.5s ease-in-out;
            --tile-color: var(--danger) !important;
            color: #101012 !important;
            --shadow-color: var(--danger-dark) !important;
        }

        .tile.draw {
            --tile-color: var(--warning) !important;
            color: #101012 !important;
            animation: waveJumpLoop 2s ease-in-out infinite;
            --shadow-color: var(--warning-dark) !important;
        }

        .tile.draw::after {
            animation: waveShadowLoop 2s ease-in-out infinite;
        }

        /* Staggering for result tiles */
        .word-result-row .tile:nth-child(1) {
            animation-delay: 0s;
        }

        .word-result-row .tile:nth-child(2) {
            animation-delay: 0.1s;
        }

        .word-result-row .tile:nth-child(3) {
            animation-delay: 0.2s;
        }

        .word-result-row .tile:nth-child(4) {
            animation-delay: 0.3s;
        }

        .word-result-row .tile:nth-child(5) {
            animation-delay: 0.4s;
        }

        .word-result-row .tile:nth-child(6) {
            animation-delay: 0.5s;
        }

        .word-result-row .tile:nth-child(7) {
            animation-delay: 0.6s;
        }

        .word-result-row .tile:nth-child(8) {
            animation-delay: 0.7s;
        }

        .word-result-row .tile:nth-child(9) {
            animation-delay: 0.8s;
        }

        .word-result-row .tile:nth-child(10) {
            animation-delay: 0.9s;
        }

        /* Apply same delays to pseudo-elements */
        /* Removed ::after animation delays */

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        #result-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            flex-grow: 1;
            position: relative;
            z-index: 20;
            opacity: 0;
            animation: fadeInScale 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            margin-top: -20px;
        }

        .result-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            width: 100%;
        }

        .res-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        #res-title {
            font-size: 32px;
            font-weight: 500;
            margin: 0;
            color: white;
            text-align: center;
        }

        .res-subtitle {
            font-size: 16px;
            color: #FFFFFF;
            margin-bottom: 16px;
            margin-top: 24px;
            text-align: center;
        }

        .game-footer {
            display: flex;
            gap: 12px;
            width: 100%;
            justify-content: center;
            padding-top: 20px;
        }

        #toast {
            position: fixed;
            bottom: 120px;
            /* Above buttons */
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            border: none;
            padding: 0;
            color: white;
            font-weight: 500;
            font-size: 18px;
            z-index: 5000;
            display: none;
            box-shadow: none;
            pointer-events: none;
            text-align: center;
            width: 100%;
        }

        #game-status-message {
            position: fixed;
            bottom: 88px;
            /* Start lower */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: 500;
            font-size: 16px;
            text-align: center;
            width: 100%;
            z-index: 4000;
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s ease-out;
            pointer-events: none;
        }

        #game-status-message.visible {
            opacity: 1;
            bottom: 120px;
            /* End position */
        }
    </style>
    </style>
</head>

<body>

    <div id="toast"></div>
    <div id="game-status-message"></div>

    <!-- Logo template removed, using img tag directly -->

    <div id="screen-intro" class="screen">
        <div style="flex-grow: 1;"></div>
        <div class="logo-svg" id="intro-logo-container">
            <img src="Recursos/Logo.svg" alt="Wordly Logo" style="width: 100%; height: auto;">
        </div>
        <p class="intro-text">Introduce tu nombre para empezar</p>
        <input type="text" id="username" placeholder="Tu nombre" maxlength="10">
        <div class="btn-container">
            <button class="btn btn-primary btn-full" onclick="initMode('MULTI')">Duelo online</button>
            <button class="btn btn-secondary btn-full" onclick="initMode('SOLO')">Entrenamiento</button>
        </div>
    </div>

    <div id="screen-connect" class="screen hidden">
        <h2>Duelo online</h2>
        <p class="connect-instruction">Conecta con tu rival envi谩ndole este c贸digo</p>

        <div class="code-wrapper">
            <div id="my-code" class="code-display">Cargando ID...</div>
            <button class="btn-copy" onclick="copyCode()">Copiar c贸digo</button>
        </div>

        <div class="divider">O introduce aqu铆 el suyo</div>
        <input type="text" id="friend-code" placeholder="Pega aqu铆 el c贸digo">

        <div class="btn-container">
            <button class="btn btn-primary btn-full" onclick="joinGame()">Conectar y jugar</button>
            <button class="btn btn-ghost btn-full" onclick="location.reload()">Volver</button>
        </div>
    </div>

    <div id="screen-game" class="screen hidden">
        <div class="logo-game-svg" id="game-logo-container">
            <img src="Recursos/Logo.svg" alt="Wordly Logo" style="height: 100%; width: auto;">
        </div>

        <div id="scoreboard" class="scoreboard-container hidden">
            <div class="score-card">
                <div id="icon-p1" class="avatar-icon"></div>
                <span class="name" id="name-p1">Yo</span>
                <div class="score-row">
                    <span class="val" id="score-p1">0</span>
                    <span class="added hidden" id="added-p1">+0</span>
                </div>
            </div>
            <div id="card-timer" class="timer-card">
                <span class="timer-big" id="timer-val">60</span>
                <span class="timer-label">segundos</span>
            </div>
            <div class="score-card">
                <div id="icon-p2" class="avatar-icon"></div>
                <span class="name" id="name-p2">Rival</span>
                <div class="score-row">
                    <span class="val" id="score-p2">0</span>
                    <span class="added hidden" id="added-p2">+0</span>
                </div>
            </div>
        </div>

        <div id="game-active-area"
            style="width: 100%; display: flex; flex-direction: column; flex-grow: 1; justify-content: center;">
            <div
                style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                <div class="word-zone-container">
                    <div id="word-zone" class="word-zone"></div>
                </div>
                <div id="pool-zone" class="pool-zone"></div>
            </div>
            <div class="game-footer">
                <button id="btn-left" class="btn btn-soft-blue btn-auto" onclick="handleLeftButton()">Nueva
                    partida</button>
                <button id="btn-action" class="btn btn-white btn-auto" onclick="validateWord()">Validar</button>
            </div>
        </div>

        <div id="result-panel" class="hidden">
            <div class="result-content">
                <div id="res-icon" class="res-icon"></div>
                <h2 id="res-title">隆Has ganado!</h2>

                <div id="res-my-word" class="word-result-row" style="margin-top: 16px;"></div>

                <p id="res-subtitle" class="res-subtitle">Rival ha perdido con:</p>
                <div id="res-opp-word" class="word-result-row"></div>
            </div>

            <div style="margin-top: auto; width: 100%; display: flex; justify-content: center;">
                <button class="btn btn-soft-blue btn-auto" onclick="handleLeftButton()">Nueva partida</button>
            </div>
        </div>
    </div>

    <script>
        // --- INICIALIZACIN DE LOGOS ---
        // Logo template logic removed as we use img tags now
        window.addEventListener('DOMContentLoaded', () => {
            // No need to populate logos via JS anymore, they are directly in HTML
        });

        // --- AVATARES SVG ---
        const SVG_P1_HAPPY = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M13.5 12C12.6716 12 12 11.3284 12 10.5C12 9.67157 12.6716 9 13.5 9C14.3284 9 15 9.67157 15 10.5C15 11.3284 14.3284 12 13.5 12Z" fill="#101012"/><path d="M24.5 12C23.6716 12 23 11.3284 23 10.5C23 9.67157 23.6716 9 24.5 9C25.3284 9 26 9.67157 26 10.5C26 11.3284 25.3284 12 24.5 12Z" fill="#101012"/><path d="M12 15C15.7058 19.2352 22.2942 19.2352 26 15" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SVG_P1_NEUTRAL = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M11.5 16C10.6716 16 10 15.3284 10 14.5C10 13.6716 10.6716 13 11.5 13C12.3284 13 13 13.6716 13 14.5C13 15.3284 12.3284 16 11.5 16Z" fill="#101012"/><path d="M22.5 16C21.6716 16 21 15.3284 21 14.5C21 13.6716 21.6716 13 22.5 13C23.3284 13 24 13.6716 24 14.5C24 15.3284 23.3284 16 22.5 16Z" fill="#101012"/><path d="M12 20H22" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SVG_P1_SAD = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M13.5 18C12.6716 18 12 17.3284 12 16.5C12 15.6716 12.6716 15 13.5 15C14.3284 15 15 15.6716 15 16.5C15 17.3284 14.3284 18 13.5 18Z" fill="#101012"/><path d="M24.5 18C23.6716 18 23 17.3284 23 16.5C23 15.6716 23.6716 15 24.5 15C25.3284 15 26 15.6716 26 16.5C26 17.3284 25.3284 18 24.5 18Z" fill="#101012"/><path d="M14 22C16.7614 19.2386 21.2386 19.2386 24 22" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SVG_P2_HAPPY = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M7.5 12C6.67157 12 6 11.3284 6 10.5C6 9.67157 6.67157 9 7.5 9C8.32843 9 9 9.67157 9 10.5C9 11.3284 8.32843 12 7.5 12Z" fill="#101012"/><path d="M18.5 12C17.6716 12 17 11.3284 17 10.5C17 9.67157 17.6716 9 18.5 9C19.3284 9 20 9.67157 20 10.5C20 11.3284 19.3284 12 18.5 12Z" fill="#101012"/><path d="M6 15C9.70577 19.2352 16.2942 19.2352 20 15" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SVG_P2_NEUTRAL = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M9.5 16C8.67157 16 8 15.3284 8 14.5C8 13.6716 8.67157 13 9.5 13C10.3284 13 11 13.6716 11 14.5C11 15.3284 10.3284 16 9.5 16Z" fill="#101012"/><path d="M20.5 16C19.6716 16 19 15.3284 19 14.5C19 13.6716 19.6716 13 20.5 13C21.3284 13 22 13.6716 22 14.5C22 15.3284 21.3284 16 20.5 16Z" fill="#101012"/><path d="M10 20H20" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SVG_P2_SAD = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="white"/><path d="M7.5 18C6.67157 18 6 17.3284 6 16.5C6 15.6716 6.67157 15 7.5 15C8.32843 15 9 15.6716 9 16.5C9 17.3284 8.32843 18 7.5 18Z" fill="#101012"/><path d="M18.5 18C17.6716 18 17 17.3284 17 16.5C17 15.6716 17.6716 15 18.5 15C19.3284 15 20 15.6716 20 16.5C20 17.3284 19.3284 18 18.5 18Z" fill="#101012"/><path d="M8 22C10.7614 19.2386 15.2386 19.2386 18 22" stroke="#101012" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

        const VOWEL_BAG = "AAAAAAAAAAAAEEEEEEEEEEEEIIIIIIOOOOOOOOUUUU";
        const CONSONANT_BAG = "SSSSSSSSRRRRRRNNNNNLLLLTTTTDDDDCCCGGGMBBPPHFVYQJXZKW";
        const COMMON_CONSONANTS = "SRNLTDC";
        const ROUND_TIME = 60;

        let state = { mode: 'SOLO', role: 'HOST', myName: '', oppName: 'Rival', myScore: 0, oppScore: 0, letters: [], timeLeft: ROUND_TIME, myWord: null, oppWord: null };
        let peer, conn, timerId;

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function initMode(mode) {
            const name = document.getElementById('username').value.trim();
            if (!name) return alert("Por favor, introduce tu nombre");
            state.myName = name.substring(0, 8); state.mode = mode;
            document.getElementById('name-p1').innerText = state.myName;

            if (mode === 'SOLO') {
                document.body.classList.add('no-bg');
                document.getElementById('screen-game').style.justifyContent = "flex-start";
                document.getElementById('scoreboard').classList.remove('hidden');
                document.getElementById('game-logo-container').classList.remove('hidden');

                // Hide P2 score card in SOLO
                document.querySelectorAll('.score-card')[1].classList.add('hidden');

                state.oppName = ""; // No opponent
                startGameUI(); hostGameLogic();
            } else {
                document.querySelectorAll('.score-card')[1].classList.remove('hidden'); // Ensure visible in MULTI
                document.getElementById('screen-game').style.justifyContent = "flex-start";
                document.getElementById('scoreboard').classList.remove('hidden');
                document.getElementById('game-logo-container').classList.remove('hidden');
                showScreen('screen-connect'); initPeer();
            }
        }

        function startGameUI() {
            document.body.classList.add('no-bg');
            showScreen('screen-game');
            document.getElementById('name-p2').innerText = state.oppName;
            updateAvatars();
        }

        function hostGameLogic() {
            let letters = [];
            const numVowels = Math.random() > 0.5 ? 4 : 5;
            for (let i = 0; i < numVowels; i++) letters.push(randChar(VOWEL_BAG));

            const numConsonants = 10 - numVowels;
            // 3 common consonants
            for (let i = 0; i < 3; i++) letters.push(randChar(COMMON_CONSONANTS));
            // The rest random from full bag
            for (let i = 0; i < numConsonants - 3; i++) letters.push(randChar(CONSONANT_BAG));

            letters.sort(() => Math.random() - 0.5);
            startRound(letters);
            if (state.mode === 'MULTI') sendData({ type: 'NEW_GAME', letters: letters });
        }

        function startRound(letters) {
            state.letters = letters; state.myWord = null; state.oppWord = null; state.timeLeft = ROUND_TIME;

            document.getElementById('score-p1').innerText = state.myScore;
            document.getElementById('score-p2').innerText = state.oppScore;
            document.getElementById('added-p1').classList.add('hidden');
            document.getElementById('added-p2').classList.add('hidden');

            document.getElementById('game-active-area').classList.remove('hidden');
            document.getElementById('result-panel').classList.add('hidden');

            document.getElementById('card-timer').classList.remove('collapsed');
            if (state.mode === 'SOLO') document.getElementById('card-timer').classList.add('hidden'); // Hide timer in SOLO
            else document.getElementById('card-timer').classList.remove('hidden');

            const btnAction = document.getElementById('btn-action');
            btnAction.disabled = false;
            btnAction.innerText = "Validar";
            btnAction.classList.remove('hidden');
            btnAction.style.opacity = "1"; // Explicitly reset opacity

            const btnLeft = document.getElementById('btn-left');
            btnLeft.innerText = "Nueva partida";
            btnLeft.onclick = handleLeftButton;
            btnLeft.classList.remove('hidden');

            renderBoard(letters);
            if (state.mode === 'MULTI') startTimer();
        }

        function handleLeftButton() {
            if (state.mode === 'SOLO') hostGameLogic();
            else if (document.getElementById('result-panel').classList.contains('hidden') === false) triggerRematch();
        }

        function renderBoard(letters) {
            const pool = document.getElementById('pool-zone');
            const word = document.getElementById('word-zone');
            pool.innerHTML = '';
            word.innerHTML = '';

            // Reset container width explicitly at start of round
            document.querySelector('.word-zone-container').style.width = '100%';

            letters.forEach((char, i) => {
                const tile = document.createElement('div'); tile.className = 'tile'; tile.textContent = char; tile.id = `t-${i}`;
                tile.onclick = () => { if (state.myWord) return; if (tile.parentElement === word) returnToEmptySlot(tile); else word.appendChild(tile); };
                const slot = document.createElement('div'); slot.className = 'slot'; slot.appendChild(tile); pool.appendChild(slot);
            });
        }
        function returnToEmptySlot(tile) {
            const slots = document.querySelectorAll('.pool-zone .slot');
            for (let s of slots) { if (s.children.length === 0) { s.appendChild(tile); break; } }
        }

        function startTimer() { clearInterval(timerId); updateTimerDisplay(); timerId = setInterval(() => { state.timeLeft--; updateTimerDisplay(); if (state.timeLeft <= 0) { clearInterval(timerId); timeUp(); } }, 1000); }
        function updateTimerDisplay() {
            const el = document.getElementById('timer-val');
            el.innerText = state.timeLeft;
            if (state.timeLeft <= 10) el.style.color = '#FF5F22';
            else if (state.timeLeft <= 20) el.style.color = '#FFB900';
            else el.style.color = '#FFFFFF';
        }
        function timeUp() { if (!state.myWord) submitWord(true); }

        function animateFailureAndReset(tiles) {
            const wordZone = document.getElementById('word-zone');
            const poolZone = document.getElementById('pool-zone');
            const btn = document.getElementById('btn-action');

            tiles.forEach((t, index) => {
                setTimeout(() => {
                    t.classList.remove('validating');
                    t.classList.add('fail');
                }, index * 80);
            });

            // Add error class to container
            const container = document.querySelector('.word-zone-container');
            container.classList.add('container-error');

            setTimeout(() => {
                tiles.forEach(t => {
                    t.classList.remove('fail');
                    t.style.transform = ''; // Reset any transform applied by shake
                    t.style.backgroundColor = ''; // Explicitly clear inline background color if any
                });

                // Move tiles back to pool
                // Collect tiles from wordZone first to avoid issues with live NodeList
                const tilesToMove = Array.from(wordZone.children);
                tilesToMove.forEach(tile => {
                    // Reset class to base tile class to ensure no residual state classes
                    tile.className = 'tile';

                    // Find an empty slot in the pool or just append
                    const slots = poolZone.querySelectorAll('.slot');
                    let moved = false;
                    for (let s of slots) {
                        if (s.children.length === 0) {
                            s.appendChild(tile);
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) { // Fallback if no empty slot found
                        const slot = document.createElement('div');
                        slot.className = 'slot';
                        slot.appendChild(tile);
                        poolZone.appendChild(slot);
                    }
                    // Re-bind click handler to move to word zone
                    tile.onclick = () => { if (state.myWord) return; if (tile.parentElement.parentElement === poolZone) wordZone.appendChild(tile); else returnToEmptySlot(tile); };

                    // Force remove any inline styles that might persist
                    tile.removeAttribute('style');
                });

                state.myWord = null; // Reset myWord state
                btn.disabled = false;
                btn.innerText = "Validar";
                btn.style.opacity = "1"; // Reset opacity

                // Reset container width to full and remove error class
                const container = document.querySelector('.word-zone-container');
                container.style.width = '100%';
                container.classList.remove('container-error');

            }, 1000); // Duration for the fail animation and reset
        }

        async function validateWord() {
            const btn = document.getElementById('btn-action'); btn.disabled = true; btn.innerText = "Validando...";
            let wordStr = ""; document.querySelectorAll('#word-zone .tile').forEach(t => wordStr += t.textContent);

            const doShake = () => {
                const myTiles = document.querySelectorAll('#word-zone .tile');
                myTiles.forEach(t => {
                    t.classList.remove('shake');
                    void t.offsetWidth;
                    t.classList.add('shake');
                });
            };

            const myTiles = document.querySelectorAll('#word-zone .tile');

            if (wordStr.length < 2) {
                showToast("锔 M铆nimo 2 letras");
                doShake();
                animateFailureAndReset(myTiles); // Call the new function for visual feedback and reset
                return;
            }

            try {
                const res = await fetch(`https://es.wiktionary.org/w/api.php?action=query&titles=${wordStr.toLowerCase()}&format=json&origin=*`);
                const data = await res.json();
                if (Object.keys(data.query.pages)[0] === "-1") {
                    showToast(` 隆No te inventes palabras!`); // Invalid word message
                    btn.disabled = false; btn.innerText = "Validar";
                    myTiles.forEach(t => t.classList.remove('validating'));
                    doShake();
                    animateFailureAndReset(myTiles);
                    return;
                }
            } catch (e) {
                // Re-enable button on error
                const btn = document.getElementById('btn-action');
                btn.disabled = false;
                btn.innerText = "Validar";
                return;
            }

            // Success - Trigger validation animation and shrink container
            shrinkContainer();
            myTiles.forEach((t, index) => { setTimeout(() => { t.classList.add('validating'); }, index * 80); });
            await new Promise(r => setTimeout(r, 800)); // Wait for animation

            if (state.mode === 'SOLO') {
                animateSuccessAndClear(myTiles);
                showGameStatus(" 隆Palabra correcta!", 2000);
                btn.innerText = "隆Correcto!";

                // Update score immediately for SOLO
                const score = wordStr.length; // Simple scoring: 1 point per letter? Or use existing logic?
                // Existing logic is in finishRound usually. Let's just add length for now or reuse logic.
                // Actually, let's just do:
                state.myScore += wordStr.length;
                document.getElementById('score-p1').innerText = state.myScore;
                updateAddedScore('added-p1', wordStr.length, 'win');
                setTimeout(() => document.getElementById('score-p1').classList.add('pop'), 50);
                setTimeout(() => document.getElementById('score-p1').classList.remove('pop'), 350);

                setTimeout(() => {
                    hostGameLogic(); // Start new round directly
                }, 2000);
                return;
            }
            submitWord(false, wordStr);
        }

        function animateSuccessAndClear(tiles) {
            document.getElementById('pool-zone').innerHTML = '';
            tiles.forEach((t, index) => { setTimeout(() => { t.classList.add('success'); }, index * 50); });
            confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            // The message " 隆Palabra correcta!" is now handled by showGameStatus in validateWord with a duration.
        }

        function submitWord(forced, wordStr = "") {
            state.myWord = wordStr;
            const btn = document.getElementById('btn-action');
            btn.disabled = true;
            btn.innerText = "Enviado";
            btn.style.opacity = "0.4";

            // Clear pool to avoid stuck hover states
            document.getElementById('pool-zone').innerHTML = '';

            if (state.mode === 'MULTI' && !state.oppWord) {
                showGameStatus(`ケ Esperando a ${state.oppName}...`); // Waiting message
            }
            if (state.mode === 'MULTI') {
                // Container already shrunk in validateWord
                sendData({ type: 'SUBMIT', word: wordStr });
                checkEndRound();
            }
        }

        function checkEndRound() {
            if (state.myWord !== null && state.oppWord !== null) {
                clearInterval(timerId);
                hideGameStatus(); // Hide any status message
                finishRound();
            }
        }

        function finishRound() {
            document.getElementById('card-timer').classList.add('collapsed');
            const myLen = state.myWord ? state.myWord.length : 0;
            const oppLen = state.oppWord ? state.oppWord.length : 0;

            let type = "DRAW";
            let p1AddScore = 0, p2AddScore = 0;
            let p1Class = "", p2Class = "";

            if (myLen > oppLen) {
                type = "WIN"; state.myScore += myLen; p1AddScore = myLen; p1Class = "win";
                confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            }
            else if (myLen < oppLen) {
                type = "LOSE"; state.oppScore += oppLen; p2AddScore = oppLen; p2Class = "win";
            }
            else {
                type = "DRAW"; state.myScore += myLen; state.oppScore += oppLen;
                p1AddScore = myLen; p2AddScore = oppLen;
                p1Class = "draw"; p2Class = "draw";
            }

            updateAddedScore('added-p1', p1AddScore, p1Class);
            updateAddedScore('added-p2', p2AddScore, p2Class);

            updateAvatars(type);
            showResultPanel(type);

            setTimeout(() => {
                startScoreAnimation('p1', p1AddScore);
                startScoreAnimation('p2', p2AddScore);
            }, 1500);
        }

        function startScoreAnimation(player, addedScore) {
            if (addedScore === 0) return;

            const addedEl = document.getElementById(`added-${player}`);
            const scoreEl = document.getElementById(`score-${player}`);
            const isP1 = player === 'p1';

            // Just show added score statically
            addedEl.classList.remove('hidden');
            addedEl.classList.add('visible');

            // Update total score immediately (or after a short delay if preferred, but user asked for static added points)
            // Let's keep the logic where added points stay visible for a bit then disappear?
            // "Pon los puntos que se a帽aden al lado del total pero est谩ticos" -> "Put the added points next to total but static"
            // "Que desaparezcan (solo con fade) y se anime el total" -> "Make them disappear (fade only) and animate total"

            setTimeout(() => {
                // Hide added score (fade out)
                addedEl.classList.remove('visible');

                setTimeout(() => {
                    addedEl.classList.add('hidden');
                    // Update total score and pop
                    scoreEl.innerText = isP1 ? state.myScore : state.oppScore;

                    // Check if it was a draw to apply yellow color to pop
                    const isDraw = addedEl.classList.contains('draw');
                    if (isDraw) scoreEl.style.color = 'var(--warning)';

                    scoreEl.classList.add('pop');

                    setTimeout(() => {
                        scoreEl.classList.remove('pop');
                        scoreEl.style.color = ''; // Reset color
                    }, 300);
                }, 500); // Wait for fade out
            }, 1500); // Keep them visible for 1.5s
        }

        function updateAddedScore(id, score, cls) {
            const el = document.getElementById(id);
            if (cls && score > 0) {
                el.innerText = `+${score}`;
                el.className = `added ${cls}`; // Reset classes, keep 'added' and type
                // Don't show yet, wait for animation trigger
            } else {
                el.classList.add('hidden');
                el.classList.remove('visible');
            }
        }

        function shrinkContainer() {
            const container = document.querySelector('.word-zone-container');
            const tiles = document.querySelectorAll('#word-zone .tile');
            const tileWidth = 32;
            const tileGap = 4;
            const containerPadding = 16; // 8px padding on each side (if any, or just visual buffer)
            // Actually .word-zone has gap 4px. Container has no padding defined in CSS but let's keep the logic if it looked good.
            // Wait, .word-zone-container is just a wrapper. .word-zone is the flex container.
            // If we shrink the wrapper, we center the content.
            // Let's calculate exact width needed.
            const contentWidth = (tiles.length * tileWidth) + ((tiles.length - 1) * tileGap) + 16; // +16 for safety/padding
            container.style.width = `${contentWidth}px`;
        }

        function showResultPanel(type) {
            document.getElementById('game-active-area').classList.add('hidden');
            document.getElementById('result-panel').classList.remove('hidden');

            // Update avatars based on result
            updateAvatars(type);

            const icon = document.getElementById('res-icon');
            const title = document.getElementById('res-title');
            const subtitle = document.getElementById('res-subtitle');

            const myContainer = document.getElementById('res-my-word');
            const oppContainer = document.getElementById('res-opp-word');

            // Reset visibility and opacities
            [icon, title, subtitle].forEach(el => el.style.opacity = '1');
            myContainer.style.display = 'inline-flex';
            oppContainer.style.display = 'inline-flex';

            if (type === 'WIN') {
                icon.innerText = ""; title.innerText = "隆Has ganado!";
                if (state.oppWord) {
                    subtitle.innerText = `${state.oppName} ha perdido con:`;
                    renderResultTiles('res-opp-word', state.oppWord, 'fail');
                    oppContainer.className = 'word-result-row container-lose';
                } else {
                    subtitle.innerText = `隆A ${state.oppName} se le ha acabado el tiempo!`;
                    oppContainer.style.display = 'none'; // Hide container
                }
                renderResultTiles('res-my-word', state.myWord, 'success');
                myContainer.className = 'word-result-row container-win';
            } else if (type === 'LOSE') {
                if (!state.myWord) {
                    icon.innerText = ""; title.innerText = "隆Se acab贸 el tiempo!";
                    subtitle.innerText = `${state.oppName} ha ganado con:`;
                    myContainer.style.display = 'none'; // Hide container
                } else {
                    icon.innerText = ""; title.innerText = "Oh... 隆has perdido!";
                    subtitle.innerText = `${state.oppName} ha ganado con:`;
                    renderResultTiles('res-my-word', state.myWord, 'fail');
                    myContainer.className = 'word-result-row container-lose';
                }
                renderResultTiles('res-opp-word', state.oppWord, 'success');
                oppContainer.className = 'word-result-row container-win';
            } else {
                if (!state.myWord && !state.oppWord) {
                    icon.innerText = ""; title.innerText = "隆Se acab贸 el tiempo!";
                    subtitle.innerText = "隆Hab茅is perdido los dos, vaya disgusto!";
                    myContainer.style.display = 'none';
                    oppContainer.style.display = 'none';
                } else {
                    icon.innerText = ""; title.innerText = "隆Hab茅is empatado!";
                    subtitle.innerText = `${state.oppName} ha puesto:`;
                    renderResultTiles('res-my-word', state.myWord, 'draw');
                    renderResultTiles('res-opp-word', state.oppWord, 'draw');
                    myContainer.className = 'word-result-row container-draw';
                    oppContainer.className = 'word-result-row container-draw';
                }
            }
        }

        function renderResultTiles(containerId, word, statusClass) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            if (!word) word = "";
            word.split('').forEach((char, index) => {
                const tile = document.createElement('div');
                tile.className = `tile`;
                tile.textContent = char;
                tile.style.animationDelay = `${index * 0.1}s`;
                if (statusClass === 'success') tile.classList.add('success');
                else if (statusClass === 'draw') tile.classList.add('draw');
                else if (statusClass === 'fail') tile.classList.add('fail');
                container.appendChild(tile);
            });
        }

        function setAvatar(containerId, type) {
            const el = document.getElementById(containerId);
            let svgData;
            if (containerId === 'icon-p1') {
                if (type === 'happy') svgData = SVG_P1_HAPPY;
                else if (type === 'sad') svgData = SVG_P1_SAD;
                else svgData = SVG_P1_NEUTRAL;
            } else if (containerId === 'icon-p2') {
                if (type === 'happy') svgData = SVG_P2_HAPPY;
                else if (type === 'sad') svgData = SVG_P2_SAD;
                else svgData = SVG_P2_NEUTRAL;
            }
            el.innerHTML = svgData;
        }

        function updateAvatars(roundResult) {
            let p1State = 'neutral';
            let p2State = 'neutral';

            if (roundResult) {
                // End of round logic
                if (roundResult === 'WIN') { p1State = 'happy'; p2State = 'sad'; }
                else if (roundResult === 'LOSE') { p1State = 'sad'; p2State = 'happy'; }
                else { p1State = 'neutral'; p2State = 'neutral'; }
            } else {
                // Start of game / Score based logic
                if (state.myScore > state.oppScore) { p1State = 'happy'; p2State = 'sad'; }
                else if (state.myScore < state.oppScore) { p1State = 'sad'; p2State = 'happy'; }
                else { p1State = 'neutral'; p2State = 'neutral'; }
            }
            setAvatar('icon-p1', p1State);
            setAvatar('icon-p2', p2State);
        }

        function triggerRematch() { if (state.mode === 'SOLO') hostGameLogic(); else { if (state.role === 'HOST') hostGameLogic(); else sendData({ type: 'REMATCH' }); } }
        function initPeer() {
            if (peer) return;
            const peerConfig = {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' },
                    ]
                }
            };
            peer = new Peer(null, peerConfig);
            peer.on('open', (id) => document.getElementById('my-code').innerText = id);
            peer.on('connection', (c) => { state.role = 'HOST'; setupConn(c); });
            peer.on('error', (err) => showToast("Error: " + (err.type === 'peer-unavailable' ? 'Rival no encontrado' : err.type)));
        }
        function joinGame() {
            const code = document.getElementById('friend-code').value.trim();
            if (!code) return showToast("Introduce un c贸digo");
            state.role = 'GUEST';
            // showToast("Conectando..."); // Removed to avoid overlap
            setupConn(peer.connect(code));
        }
        function setupConn(c) {
            conn = c;
            const sendHello = () => conn.send({ type: 'HELLO', name: state.myName });
            if (conn.open) sendHello();
            else conn.on('open', sendHello);

            conn.on('data', (d) => {
                if (d.type === 'HELLO') {
                    state.oppName = d.name;
                    startGameUI();
                    showGameStatus(` Te has conectado con ${state.oppName}`, 3000); // Connection message with 3s duration
                    if (state.role === 'HOST') setTimeout(hostGameLogic, 500);
                }
                if (d.type === 'NEW_GAME') startRound(d.letters);
                if (d.type === 'SUBMIT') {
                    state.oppWord = d.word;
                    checkEndRound();
                    if (state.myWord) {
                        // Both finished
                    } else {
                        showGameStatus(`锔 隆${state.oppName} ya ha acabado!`); // Opponent finished first
                    }
                }
                if (d.type === 'REMATCH') hostGameLogic();
            });
            conn.on('error', (err) => showToast("Error conexi贸n: " + err));
            conn.on('close', () => showToast("Conexi贸n cerrada"));
        }
        function sendData(d) { if (conn && conn.open) conn.send(d); }
        function randChar(str) { return str.charAt(Math.floor(Math.random() * str.length)); }
        function copyCode() {
            const code = document.getElementById('my-code').innerText;
            if (code.includes("...")) return;
            navigator.clipboard.writeText(code);
            const btn = document.querySelector('.btn-copy');
            const originalText = btn.innerText;
            btn.innerText = "C贸digo copiado";
            setTimeout(() => {
                btn.innerText = "Copiar c贸digo";
            }, 5000);
        }
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 3000);
        }

        function showGameStatus(msg, duration = 0) {
            const el = document.getElementById('game-status-message');
            el.innerText = msg;
            el.classList.add('visible');
            if (duration > 0) {
                setTimeout(() => el.classList.remove('visible'), duration);
            }
        }

        function hideGameStatus() {
            document.getElementById('game-status-message').classList.remove('visible');
        }
    </script>
</body>

</html>